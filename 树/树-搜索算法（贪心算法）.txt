DFS非常简单，在搜索的过程中一旦遇到一个未标记的顶点，就沿着这个顶点继续搜索，
	直至遍历完所有可达的顶点。DFS具有回溯的性质，由此形成的搜索树很瘦很高。
	执行DFS时，同时会维护一个时间戳（time-stamp），以此记录每个顶点被搜索到的顺序，
	DFS形成的搜索树包含不同类型的边（树边，回边，下边以及交叉边），边的性质能通过时间戳识别出来。

BFS则相反，遇到一个未搜索的顶点时，先将与该顶点邻接的搜索完，然后进入下一轮搜索。
	与源点距离为k+1的顶点总是在所有与源点距离小于等于k的所有顶点都搜索完之后才被遍历。
	对于不区分边权值的图，BFS能计算出最短路径――DFS对此无能为力。

Prim算法是计算最小生成树（minimum spanning tree，MST）的经典算法，在计算最小生成树的过程中，
	Prim算法维护图的一个割（cut），割区分了树顶点（被选入MST的顶点）和非树顶点，
	树顶点集合构成了该图的部分MST（part MST）。每一次向树顶点集合加入新顶点时，
	都选取距离部分MST最近的非树顶点，显然，相同的操作重复V-1次后，
	所有顶点都已加入树顶点集，最小生成树计算完毕。

Dijkstra算法可以解决非负权值的单源最短路径问题（shortest-paths problem），
	我们可以采用与Prim算法几乎一样的思想：
	计算最短路径的过程中维护一棵最短路径树（shortest-paths tree，SPT），
	包含了最短路径上的顶点。最开始这棵树中只有源点，作为树根。
	每次向SPT增加新顶点时，都选取非树顶点中与源点距离最近的顶点。
	相同的操作重复V-1次后，最短路径树计算完毕。与BFS类似，Dijkstra算法形成的搜索树偏胖~